/*! (c) 2019-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
import*as e from"three";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function r(e,r,t,n){return new(t||(t=Promise))((function(i,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var r;e.done?i(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(s,a)}l((n=n.apply(e,r||[])).next())}))}function t(e){Object.keys(e).forEach((r=>{const t=e[r];if(null==t?void 0:t.isTexture){t.dispose()}})),e.dispose()}function n(e){const r=e.geometry;r&&r.dispose();const n=e.material;n&&(Array.isArray(n)?n.forEach((e=>t(e))):n&&t(n))}var i;!function(e){e[e.NUMBER=0]="NUMBER",e[e.VECTOR2=1]="VECTOR2",e[e.VECTOR3=2]="VECTOR3",e[e.VECTOR4=3]="VECTOR4",e[e.COLOR=4]="COLOR"}(i||(i={}));const o=new e.Vector2,s=new e.Vector3,a=new e.Vector4,l=new e.Color;class d extends e.Object3D{constructor(e){super(),this.weight=0,this.isBinary=!1,this._binds=[],this._materialValues=[],this.name=`BlendShapeController_${e}`,this.type="BlendShapeController",this.visible=!1}addBind(e){const r=e.weight/100;this._binds.push({meshes:e.meshes,morphTargetIndex:e.morphTargetIndex,weight:r})}addMaterialValue(r){const t=r.material,n=r.propertyName;let o,s,a,l,d=t[n];d&&(d=r.defaultValue||d,d.isVector2?(o=i.VECTOR2,s=d.clone(),a=(new e.Vector2).fromArray(r.targetValue),l=a.clone().sub(s)):d.isVector3?(o=i.VECTOR3,s=d.clone(),a=(new e.Vector3).fromArray(r.targetValue),l=a.clone().sub(s)):d.isVector4?(o=i.VECTOR4,s=d.clone(),a=(new e.Vector4).fromArray([r.targetValue[2],r.targetValue[3],r.targetValue[0],r.targetValue[1]]),l=a.clone().sub(s)):d.isColor?(o=i.COLOR,s=d.clone(),a=(new e.Color).fromArray(r.targetValue),l=a.clone().sub(s)):(o=i.NUMBER,s=d,a=r.targetValue[0],l=a-s),this._materialValues.push({material:t,propertyName:n,defaultValue:s,targetValue:a,deltaValue:l,type:o}))}applyWeight(){const e=this.isBinary?this.weight<.5?0:1:this.weight;this._binds.forEach((r=>{r.meshes.forEach((t=>{t.morphTargetInfluences&&(t.morphTargetInfluences[r.morphTargetIndex]+=e*r.weight)}))})),this._materialValues.forEach((r=>{if(void 0!==r.material[r.propertyName]){if(r.type===i.NUMBER){const t=r.deltaValue;r.material[r.propertyName]+=t*e}else if(r.type===i.VECTOR2){const t=r.deltaValue;r.material[r.propertyName].add(o.copy(t).multiplyScalar(e))}else if(r.type===i.VECTOR3){const t=r.deltaValue;r.material[r.propertyName].add(s.copy(t).multiplyScalar(e))}else if(r.type===i.VECTOR4){const t=r.deltaValue;r.material[r.propertyName].add(a.copy(t).multiplyScalar(e))}else if(r.type===i.COLOR){const t=r.deltaValue;r.material[r.propertyName].add(l.copy(t).multiplyScalar(e))}"boolean"==typeof r.material.shouldApplyUniforms&&(r.material.shouldApplyUniforms=!0)}}))}clearAppliedWeight(){this._binds.forEach((e=>{e.meshes.forEach((r=>{r.morphTargetInfluences&&(r.morphTargetInfluences[e.morphTargetIndex]=0)}))})),this._materialValues.forEach((e=>{if(void 0!==e.material[e.propertyName]){if(e.type===i.NUMBER){const r=e.defaultValue;e.material[e.propertyName]=r}else if(e.type===i.VECTOR2){const r=e.defaultValue;e.material[e.propertyName].copy(r)}else if(e.type===i.VECTOR3){const r=e.defaultValue;e.material[e.propertyName].copy(r)}else if(e.type===i.VECTOR4){const r=e.defaultValue;e.material[e.propertyName].copy(r)}else if(e.type===i.COLOR){const r=e.defaultValue;e.material[e.propertyName].copy(r)}"boolean"==typeof e.material.shouldApplyUniforms&&(e.material.shouldApplyUniforms=!0)}}))}}var h;function u(e,r,t){const n=e.parser.json.nodes[r].mesh;if(null==n)return null;const i=e.parser.json.meshes[n].primitives.length,o=[];return t.traverse((e=>{o.length<i&&e.isMesh&&o.push(e)})),o}function c(e){return r(this,void 0,void 0,(function*(){const r=yield e.parser.getDependencies("node"),t=new Map;return r.forEach(((r,n)=>{const i=u(e,n,r);null!=i&&t.set(n,i)})),t}))}function p(e){return"_"!==e[0]?(console.warn(`renameMaterialProperty: Given property name "${e}" might be invalid`),e):(e=e.substring(1),/[A-Z]/.test(e[0])?e[0].toLowerCase()+e.substring(1):(console.warn(`renameMaterialProperty: Given property name "${e}" might be invalid`),e))}!function(e){var r,t,n,i,o,s;(r=e.BlendShapePresetName||(e.BlendShapePresetName={})).A="a",r.Angry="angry",r.Blink="blink",r.BlinkL="blink_l",r.BlinkR="blink_r",r.E="e",r.Fun="fun",r.I="i",r.Joy="joy",r.Lookdown="lookdown",r.Lookleft="lookleft",r.Lookright="lookright",r.Lookup="lookup",r.Neutral="neutral",r.O="o",r.Sorrow="sorrow",r.U="u",r.Unknown="unknown",(t=e.FirstPersonLookAtTypeName||(e.FirstPersonLookAtTypeName={})).BlendShape="BlendShape",t.Bone="Bone",(n=e.HumanoidBoneName||(e.HumanoidBoneName={})).Chest="chest",n.Head="head",n.Hips="hips",n.Jaw="jaw",n.LeftEye="leftEye",n.LeftFoot="leftFoot",n.LeftHand="leftHand",n.LeftIndexDistal="leftIndexDistal",n.LeftIndexIntermediate="leftIndexIntermediate",n.LeftIndexProximal="leftIndexProximal",n.LeftLittleDistal="leftLittleDistal",n.LeftLittleIntermediate="leftLittleIntermediate",n.LeftLittleProximal="leftLittleProximal",n.LeftLowerArm="leftLowerArm",n.LeftLowerLeg="leftLowerLeg",n.LeftMiddleDistal="leftMiddleDistal",n.LeftMiddleIntermediate="leftMiddleIntermediate",n.LeftMiddleProximal="leftMiddleProximal",n.LeftRingDistal="leftRingDistal",n.LeftRingIntermediate="leftRingIntermediate",n.LeftRingProximal="leftRingProximal",n.LeftShoulder="leftShoulder",n.LeftThumbDistal="leftThumbDistal",n.LeftThumbIntermediate="leftThumbIntermediate",n.LeftThumbProximal="leftThumbProximal",n.LeftToes="leftToes",n.LeftUpperArm="leftUpperArm",n.LeftUpperLeg="leftUpperLeg",n.Neck="neck",n.RightEye="rightEye",n.RightFoot="rightFoot",n.RightHand="rightHand",n.RightIndexDistal="rightIndexDistal",n.RightIndexIntermediate="rightIndexIntermediate",n.RightIndexProximal="rightIndexProximal",n.RightLittleDistal="rightLittleDistal",n.RightLittleIntermediate="rightLittleIntermediate",n.RightLittleProximal="rightLittleProximal",n.RightLowerArm="rightLowerArm",n.RightLowerLeg="rightLowerLeg",n.RightMiddleDistal="rightMiddleDistal",n.RightMiddleIntermediate="rightMiddleIntermediate",n.RightMiddleProximal="rightMiddleProximal",n.RightRingDistal="rightRingDistal",n.RightRingIntermediate="rightRingIntermediate",n.RightRingProximal="rightRingProximal",n.RightShoulder="rightShoulder",n.RightThumbDistal="rightThumbDistal",n.RightThumbIntermediate="rightThumbIntermediate",n.RightThumbProximal="rightThumbProximal",n.RightToes="rightToes",n.RightUpperArm="rightUpperArm",n.RightUpperLeg="rightUpperLeg",n.Spine="spine",n.UpperChest="upperChest",(i=e.MetaAllowedUserName||(e.MetaAllowedUserName={})).Everyone="Everyone",i.ExplicitlyLicensedPerson="ExplicitlyLicensedPerson",i.OnlyAuthor="OnlyAuthor",(o=e.MetaUssageName||(e.MetaUssageName={})).Allow="Allow",o.Disallow="Disallow",(s=e.MetaLicenseName||(e.MetaLicenseName={})).Cc0="CC0",s.CcBy="CC_BY",s.CcByNc="CC_BY_NC",s.CcByNcNd="CC_BY_NC_ND",s.CcByNcSa="CC_BY_NC_SA",s.CcByNd="CC_BY_ND",s.CcBySa="CC_BY_SA",s.Other="Other",s.RedistributionProhibited="Redistribution_Prohibited"}(h||(h={}));const m=new e.Vector3,f=new e.Vector3;function g(e,r){return e.matrixWorld.decompose(m,r,f),r}new e.Quaternion;class _{constructor(){this._blendShapeGroups={},this._blendShapePresetMap={},this._unknownGroupNames=[]}get expressions(){return Object.keys(this._blendShapeGroups)}get blendShapePresetMap(){return this._blendShapePresetMap}get unknownGroupNames(){return this._unknownGroupNames}getBlendShapeGroup(e){const r=this._blendShapePresetMap[e],t=r?this._blendShapeGroups[r]:this._blendShapeGroups[e];if(t)return t;console.warn(`no blend shape found by ${e}`)}registerBlendShapeGroup(e,r,t){this._blendShapeGroups[e]=t,r?this._blendShapePresetMap[r]=e:this._unknownGroupNames.push(e)}getValue(e){var r;const t=this.getBlendShapeGroup(e);return null!==(r=null==t?void 0:t.weight)&&void 0!==r?r:null}setValue(e,r){const t=this.getBlendShapeGroup(e);var n;t&&(t.weight=(n=r,Math.max(Math.min(n,1),0)))}getBlendShapeTrackName(e){const r=this.getBlendShapeGroup(e);return r?`${r.name}.weight`:null}update(){Object.keys(this._blendShapeGroups).forEach((e=>{this._blendShapeGroups[e].clearAppliedWeight()})),Object.keys(this._blendShapeGroups).forEach((e=>{this._blendShapeGroups[e].applyWeight()}))}}class v{import(e){var t;return r(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.blendShapeMaster;if(!i)return null;const o=new _,s=i.blendShapeGroups;if(!s)return o;const a={};return yield Promise.all(s.map((t=>r(this,void 0,void 0,(function*(){const n=t.name;if(void 0===n)return void console.warn("VRMBlendShapeImporter: One of blendShapeGroups has no name");let i;t.presetName&&t.presetName!==h.BlendShapePresetName.Unknown&&!a[t.presetName]&&(i=t.presetName,a[t.presetName]=n);const s=new d(n);e.scene.add(s),s.isBinary=t.isBinary||!1,t.binds&&t.binds.forEach((n=>r(this,void 0,void 0,(function*(){if(void 0===n.mesh||void 0===n.index)return;const i=[];e.parser.json.nodes.forEach(((e,r)=>{e.mesh===n.mesh&&i.push(r)}));const o=n.index;yield Promise.all(i.map((i=>r(this,void 0,void 0,(function*(){var a;const l=yield function(e,t){return r(this,void 0,void 0,(function*(){const r=yield e.parser.getDependency("node",t);return u(e,t,r)}))}(e,i);l.every((e=>Array.isArray(e.morphTargetInfluences)&&o<e.morphTargetInfluences.length))?s.addBind({meshes:l,morphTargetIndex:o,weight:null!==(a=n.weight)&&void 0!==a?a:100}):console.warn(`VRMBlendShapeImporter: ${t.name} attempts to index ${o}th morph but not found.`)})))))}))));const l=t.materialValues;l&&l.forEach((r=>{if(void 0===r.materialName||void 0===r.propertyName||void 0===r.targetValue)return;const t=[];e.scene.traverse((e=>{if(e.material){const n=e.material;Array.isArray(n)?t.push(...n.filter((e=>e.name===r.materialName&&-1===t.indexOf(e)))):n.name===r.materialName&&-1===t.indexOf(n)&&t.push(n)}})),t.forEach((e=>{s.addMaterialValue({material:e,propertyName:p(r.propertyName),targetValue:r.targetValue})}))})),o.registerBlendShapeGroup(n,i,s)}))))),o}))}}const y=Object.freeze(new e.Vector3(0,0,-1)),T=new e.Quaternion;var x;!function(e){e[e.Auto=0]="Auto",e[e.Both=1]="Both",e[e.ThirdPersonOnly=2]="ThirdPersonOnly",e[e.FirstPersonOnly=3]="FirstPersonOnly"}(x||(x={}));class M{constructor(e,r){this.firstPersonFlag=M._parseFirstPersonFlag(e),this.primitives=r}static _parseFirstPersonFlag(e){switch(e){case"Both":return x.Both;case"ThirdPersonOnly":return x.ThirdPersonOnly;case"FirstPersonOnly":return x.FirstPersonOnly;default:return x.Auto}}}class S{constructor(e,r,t){this._meshAnnotations=[],this._firstPersonOnlyLayer=S._DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=S._DEFAULT_THIRDPERSON_ONLY_LAYER,this._initialized=!1,this._firstPersonBone=e,this._firstPersonBoneOffset=r,this._meshAnnotations=t}get firstPersonBone(){return this._firstPersonBone}get meshAnnotations(){return this._meshAnnotations}getFirstPersonWorldDirection(e){return e.copy(y).applyQuaternion(g(this._firstPersonBone,T))}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}getFirstPersonBoneOffset(e){return e.copy(this._firstPersonBoneOffset)}getFirstPersonWorldPosition(r){const t=this._firstPersonBoneOffset,n=new e.Vector4(t.x,t.y,t.z,1);return n.applyMatrix4(this._firstPersonBone.matrixWorld),r.set(n.x,n.y,n.z)}setup({firstPersonOnlyLayer:e=S._DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:r=S._DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initialized||(this._initialized=!0,this._firstPersonOnlyLayer=e,this._thirdPersonOnlyLayer=r,this._meshAnnotations.forEach((e=>{e.firstPersonFlag===x.FirstPersonOnly?e.primitives.forEach((e=>{e.layers.set(this._firstPersonOnlyLayer)})):e.firstPersonFlag===x.ThirdPersonOnly?e.primitives.forEach((e=>{e.layers.set(this._thirdPersonOnlyLayer)})):e.firstPersonFlag===x.Auto&&this._createHeadlessModel(e.primitives)})))}_excludeTriangles(e,r,t,n){let i=0;if(null!=r&&r.length>0)for(let o=0;o<e.length;o+=3){const s=e[o],a=e[o+1],l=e[o+2],d=r[s],h=t[s];if(d[0]>0&&n.includes(h[0]))continue;if(d[1]>0&&n.includes(h[1]))continue;if(d[2]>0&&n.includes(h[2]))continue;if(d[3]>0&&n.includes(h[3]))continue;const u=r[a],c=t[a];if(u[0]>0&&n.includes(c[0]))continue;if(u[1]>0&&n.includes(c[1]))continue;if(u[2]>0&&n.includes(c[2]))continue;if(u[3]>0&&n.includes(c[3]))continue;const p=r[l],m=t[l];p[0]>0&&n.includes(m[0])||(p[1]>0&&n.includes(m[1])||p[2]>0&&n.includes(m[2])||p[3]>0&&n.includes(m[3])||(e[i++]=s,e[i++]=a,e[i++]=l))}return i}_createErasedMesh(r,t){const n=new e.SkinnedMesh(r.geometry.clone(),r.material);n.name=`${r.name}(erase)`,n.frustumCulled=r.frustumCulled,n.layers.set(this._firstPersonOnlyLayer);const i=n.geometry,o=i.getAttribute("skinIndex").array,s=[];for(let e=0;e<o.length;e+=4)s.push([o[e],o[e+1],o[e+2],o[e+3]]);const a=i.getAttribute("skinWeight").array,l=[];for(let e=0;e<a.length;e+=4)l.push([a[e],a[e+1],a[e+2],a[e+3]]);const d=i.getIndex();if(!d)throw new Error("The geometry doesn't have an index buffer");const h=Array.from(d.array),u=this._excludeTriangles(h,l,s,t),c=[];for(let e=0;e<u;e++)c[e]=h[e];return i.setIndex(c),r.onBeforeRender&&(n.onBeforeRender=r.onBeforeRender),n.bind(new e.Skeleton(r.skeleton.bones,r.skeleton.boneInverses),new e.Matrix4),n}_createHeadlessModelForSkinnedMesh(e,r){const t=[];if(r.skeleton.bones.forEach(((e,r)=>{this._isEraseTarget(e)&&t.push(r)})),!t.length)return r.layers.enable(this._thirdPersonOnlyLayer),void r.layers.enable(this._firstPersonOnlyLayer);r.layers.set(this._thirdPersonOnlyLayer);const n=this._createErasedMesh(r,t);e.add(n)}_createHeadlessModel(e){e.forEach((e=>{if("SkinnedMesh"===e.type){const r=e;this._createHeadlessModelForSkinnedMesh(r.parent,r)}else this._isEraseTarget(e)&&e.layers.set(this._thirdPersonOnlyLayer)}))}_isEraseTarget(e){return e===this._firstPersonBone||!!e.parent&&this._isEraseTarget(e.parent)}}S._DEFAULT_FIRSTPERSON_ONLY_LAYER=9,S._DEFAULT_THIRDPERSON_ONLY_LAYER=10;class L{import(t,n){var i;return r(this,void 0,void 0,(function*(){const r=null===(i=t.parser.json.extensions)||void 0===i?void 0:i.VRM;if(!r)return null;const o=r.firstPerson;if(!o)return null;const s=o.firstPersonBone;let a;if(a=void 0===s||-1===s?n.getBoneNode(h.HumanoidBoneName.Head):yield t.parser.getDependency("node",s),!a)return console.warn("VRMFirstPersonImporter: Could not find firstPersonBone of the VRM"),null;const l=o.firstPersonBoneOffset?new e.Vector3(o.firstPersonBoneOffset.x,o.firstPersonBoneOffset.y,-o.firstPersonBoneOffset.z):new e.Vector3(0,.06,0),d=[],u=yield c(t);return Array.from(u.entries()).forEach((([e,r])=>{const n=t.parser.json.nodes[e],i=o.meshAnnotations?o.meshAnnotations.find((e=>e.mesh===n.mesh)):void 0;d.push(new M(null==i?void 0:i.firstPersonFlag,r))})),new S(a,l,d)}))}}class E{constructor(e,r){this.node=e,this.humanLimit=r}}function w(e){return e.invert?e.invert():e.inverse(),e}const P=new e.Vector3,R=new e.Quaternion;class A{constructor(e,r){this.restPose={},this.humanBones=this._createHumanBones(e),this.humanDescription=r,this.restPose=this.getPose()}getPose(){const e={};return Object.keys(this.humanBones).forEach((r=>{const t=this.getBoneNode(r);if(!t)return;if(e[r])return;P.set(0,0,0),R.identity();const n=this.restPose[r];(null==n?void 0:n.position)&&P.fromArray(n.position).negate(),(null==n?void 0:n.rotation)&&w(R.fromArray(n.rotation)),P.add(t.position),R.premultiply(t.quaternion),e[r]={position:P.toArray(),rotation:R.toArray()}}),{}),e}setPose(e){Object.keys(e).forEach((r=>{const t=e[r],n=this.getBoneNode(r);if(!n)return;const i=this.restPose[r];i&&(t.position&&(n.position.fromArray(t.position),i.position&&n.position.add(P.fromArray(i.position))),t.rotation&&(n.quaternion.fromArray(t.rotation),i.rotation&&n.quaternion.multiply(R.fromArray(i.rotation))))}))}resetPose(){Object.entries(this.restPose).forEach((([e,r])=>{const t=this.getBoneNode(e);t&&((null==r?void 0:r.position)&&t.position.fromArray(r.position),(null==r?void 0:r.rotation)&&t.quaternion.fromArray(r.rotation))}))}getBone(e){var r;return null!==(r=this.humanBones[e][0])&&void 0!==r?r:void 0}getBones(e){var r;return null!==(r=this.humanBones[e])&&void 0!==r?r:[]}getBoneNode(e){var r,t;return null!==(t=null===(r=this.humanBones[e][0])||void 0===r?void 0:r.node)&&void 0!==t?t:null}getBoneNodes(e){var r,t;return null!==(t=null===(r=this.humanBones[e])||void 0===r?void 0:r.map((e=>e.node)))&&void 0!==t?t:[]}_createHumanBones(e){const r=Object.values(h.HumanoidBoneName).reduce(((e,r)=>(e[r]=[],e)),{});return e.forEach((e=>{r[e.name].push(e.bone)})),r}}class C{import(t){var n;return r(this,void 0,void 0,(function*(){const i=null===(n=t.parser.json.extensions)||void 0===n?void 0:n.VRM;if(!i)return null;const o=i.humanoid;if(!o)return null;const s=[];o.humanBones&&(yield Promise.all(o.humanBones.map((n=>r(this,void 0,void 0,(function*(){if(!n.bone||null==n.node)return;const r=yield t.parser.getDependency("node",n.node);s.push({name:n.bone,bone:new E(r,{axisLength:n.axisLength,center:n.center&&new e.Vector3(n.center.x,n.center.y,n.center.z),max:n.max&&new e.Vector3(n.max.x,n.max.y,n.max.z),min:n.min&&new e.Vector3(n.min.x,n.min.y,n.min.z),useDefaultValues:n.useDefaultValues})})}))))));const a={armStretch:o.armStretch,legStretch:o.legStretch,upperArmTwist:o.upperArmTwist,lowerArmTwist:o.lowerArmTwist,upperLegTwist:o.upperLegTwist,lowerLegTwist:o.lowerLegTwist,feetSpacing:o.feetSpacing,hasTranslationDoF:o.hasTranslationDoF};return new A(s,a)}))}}class b{constructor(e,r,t){this.curve=[0,0,0,1,1,1,1,0],this.curveXRangeDegree=90,this.curveYRangeDegree=10,void 0!==e&&(this.curveXRangeDegree=e),void 0!==r&&(this.curveYRangeDegree=r),void 0!==t&&(this.curve=t)}map(e){const r=Math.min(Math.max(e,0),this.curveXRangeDegree)/this.curveXRangeDegree;return this.curveYRangeDegree*((e,r)=>{if(e.length<8)throw new Error("evaluateCurve: Invalid curve detected! (Array length must be 8 at least)");if(e.length%4!=0)throw new Error("evaluateCurve: Invalid curve detected! (Array length must be multiples of 4");let t;for(t=0;;t++){if(e.length<=4*t)return e[4*t-3];if(r<=e[4*t])break}const n=t-1;if(n<0)return e[4*n+5];const i=e[4*n],o=(r-i)/(e[4*t]-i);return((e,r,t,n,i)=>{const o=i*i*i,s=i*i;return e+(r-e)*(-2*o+3*s)+t*(o-2*s+i)+n*(o-s)})(e[4*n+1],e[4*t+1],e[4*n+3],e[4*t+2],o)})(this.curve,r)}}class O{}class D extends O{constructor(e,r,t,n){super(),this.type=h.FirstPersonLookAtTypeName.BlendShape,this._curveHorizontal=r,this._curveVerticalDown=t,this._curveVerticalUp=n,this._blendShapeProxy=e}name(){return h.FirstPersonLookAtTypeName.BlendShape}lookAt(e){const r=e.x,t=e.y;r<0?(this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookup,0),this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookdown,this._curveVerticalDown.map(-r))):(this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookdown,0),this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookup,this._curveVerticalUp.map(r))),t<0?(this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookleft,0),this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookright,this._curveHorizontal.map(-t))):(this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookright,0),this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookleft,this._curveHorizontal.map(t)))}}const N=Object.freeze(new e.Vector3(0,0,-1)),U=new e.Vector3,I=new e.Vector3,B=new e.Vector3,V=new e.Quaternion;class G{constructor(r,t){this.autoUpdate=!0,this._euler=new e.Euler(0,0,0,G.EULER_ORDER),this.firstPerson=r,this.applyer=t}getLookAtWorldDirection(e){const r=g(this.firstPerson.firstPersonBone,V);return e.copy(N).applyEuler(this._euler).applyQuaternion(r)}lookAt(e){this._calcEuler(this._euler,e),this.applyer&&this.applyer.lookAt(this._euler)}update(e){this.target&&this.autoUpdate&&(this.lookAt(this.target.getWorldPosition(U)),this.applyer&&this.applyer.lookAt(this._euler))}_calcEuler(e,r){const t=this.firstPerson.getFirstPersonWorldPosition(I),n=B.copy(r).sub(t).normalize();return n.applyQuaternion(w(g(this.firstPerson.firstPersonBone,V))),e.x=Math.atan2(n.y,Math.sqrt(n.x*n.x+n.z*n.z)),e.y=Math.atan2(-n.x,-n.z),e}}G.EULER_ORDER="YXZ";const F=new e.Euler(0,0,0,G.EULER_ORDER);class k extends O{constructor(e,r,t,n,i){super(),this.type=h.FirstPersonLookAtTypeName.Bone,this._curveHorizontalInner=r,this._curveHorizontalOuter=t,this._curveVerticalDown=n,this._curveVerticalUp=i,this._leftEye=e.getBoneNode(h.HumanoidBoneName.LeftEye),this._rightEye=e.getBoneNode(h.HumanoidBoneName.RightEye)}lookAt(e){const r=e.x,t=e.y;this._leftEye&&(F.x=r<0?-this._curveVerticalDown.map(-r):this._curveVerticalUp.map(r),F.y=t<0?-this._curveHorizontalInner.map(-t):this._curveHorizontalOuter.map(t),this._leftEye.quaternion.setFromEuler(F)),this._rightEye&&(F.x=r<0?-this._curveVerticalDown.map(-r):this._curveVerticalUp.map(r),F.y=t<0?-this._curveHorizontalOuter.map(-t):this._curveHorizontalInner.map(t),this._rightEye.quaternion.setFromEuler(F))}}const W=Math.PI/180;class H{import(e,r,t,n){var i;const o=null===(i=e.parser.json.extensions)||void 0===i?void 0:i.VRM;if(!o)return null;const s=o.firstPerson;if(!s)return null;const a=this._importApplyer(s,t,n);return new G(r,a||void 0)}_importApplyer(e,r,t){const n=e.lookAtHorizontalInner,i=e.lookAtHorizontalOuter,o=e.lookAtVerticalDown,s=e.lookAtVerticalUp;switch(e.lookAtTypeName){case h.FirstPersonLookAtTypeName.Bone:return void 0===n||void 0===i||void 0===o||void 0===s?null:new k(t,this._importCurveMapperBone(n),this._importCurveMapperBone(i),this._importCurveMapperBone(o),this._importCurveMapperBone(s));case h.FirstPersonLookAtTypeName.BlendShape:return void 0===i||void 0===o||void 0===s?null:new D(r,this._importCurveMapperBlendShape(i),this._importCurveMapperBlendShape(o),this._importCurveMapperBlendShape(s));default:return null}}_importCurveMapperBone(e){return new b("number"==typeof e.xRange?W*e.xRange:void 0,"number"==typeof e.yRange?W*e.yRange:void 0,e.curve)}_importCurveMapperBlendShape(e){return new b("number"==typeof e.xRange?W*e.xRange:void 0,e.yRange,e.curve)}}const z=(r,t)=>{const n=(r=>{switch(r){case e.LinearEncoding:return["Linear","( value )"];case e.sRGBEncoding:return["sRGB","( value )"];case e.RGBEEncoding:return["RGBE","( value )"];case e.RGBM7Encoding:return["RGBM","( value, 7.0 )"];case e.RGBM16Encoding:return["RGBM","( value, 16.0 )"];case e.RGBDEncoding:return["RGBD","( value, 256.0 )"];case e.GammaEncoding:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:throw new Error("unsupported encoding: "+r)}})(t);return"vec4 "+r+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"};const j=2*Math.PI;var Y,X,q,Q,Z;!function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(Y||(Y={})),function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate",e[e.UV=3]="UV"}(X||(X={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(q||(q={})),function(e){e[e.None=0]="None",e[e.WorldCoordinates=1]="WorldCoordinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(Q||(Q={})),function(e){e[e.Opaque=0]="Opaque",e[e.Cutout=1]="Cutout",e[e.Transparent=2]="Transparent",e[e.TransparentWithZWrite=3]="TransparentWithZWrite"}(Z||(Z={}));class $ extends e.ShaderMaterial{constructor(r={}){super(),this.isMToonMaterial=!0,this.cutoff=.5,this.color=new e.Vector4(1,1,1,1),this.shadeColor=new e.Vector4(.97,.81,.86,1),this.map=null,this.mainTex_ST=new e.Vector4(0,0,1,1),this.shadeTexture=null,this.normalMap=null,this.normalMapType=e.TangentSpaceNormalMap,this.normalScale=new e.Vector2(1,1),this.receiveShadowRate=1,this.receiveShadowTexture=null,this.shadingGradeRate=1,this.shadingGradeTexture=null,this.shadeShift=0,this.shadeToony=.9,this.lightColorAttenuation=0,this.indirectLightIntensity=.1,this.rimTexture=null,this.rimColor=new e.Vector4(0,0,0,1),this.rimLightingMix=0,this.rimFresnelPower=1,this.rimLift=0,this.sphereAdd=null,this.emissionColor=new e.Vector4(0,0,0,1),this.emissiveMap=null,this.outlineWidthTexture=null,this.outlineWidth=.5,this.outlineScaledMaxDistance=1,this.outlineColor=new e.Vector4(0,0,0,1),this.outlineLightingMix=1,this.uvAnimMaskTexture=null,this.uvAnimScrollX=0,this.uvAnimScrollY=0,this.uvAnimRotation=0,this.shouldApplyUniforms=!0,this._debugMode=X.None,this._blendMode=Z.Opaque,this._outlineWidthMode=Q.None,this._outlineColorMode=q.FixedColor,this._cullMode=Y.Back,this._outlineCullMode=Y.Front,this._isOutline=!1,this._uvAnimOffsetX=0,this._uvAnimOffsetY=0,this._uvAnimPhase=0,this.encoding=r.encoding||e.LinearEncoding,this.encoding!==e.LinearEncoding&&this.encoding!==e.sRGBEncoding&&console.warn("The specified color encoding does not work properly with MToonMaterial. You might want to use THREE.sRGBEncoding instead."),["mToonVersion","shadeTexture_ST","bumpMap_ST","receiveShadowTexture_ST","shadingGradeTexture_ST","rimTexture_ST","sphereAdd_ST","emissionMap_ST","outlineWidthTexture_ST","uvAnimMaskTexture_ST","srcBlend","dstBlend"].forEach((e=>{void 0!==r[e]&&delete r[e]})),r.fog=!0,r.lights=!0,r.clipping=!0,r.skinning=r.skinning||!1,r.morphTargets=r.morphTargets||!1,r.morphNormals=r.morphNormals||!1,r.uniforms=e.UniformsUtils.merge([e.UniformsLib.common,e.UniformsLib.normalmap,e.UniformsLib.emissivemap,e.UniformsLib.fog,e.UniformsLib.lights,{cutoff:{value:.5},color:{value:new e.Color(1,1,1)},colorAlpha:{value:1},shadeColor:{value:new e.Color(.97,.81,.86)},mainTex_ST:{value:new e.Vector4(0,0,1,1)},shadeTexture:{value:null},receiveShadowRate:{value:1},receiveShadowTexture:{value:null},shadingGradeRate:{value:1},shadingGradeTexture:{value:null},shadeShift:{value:0},shadeToony:{value:.9},lightColorAttenuation:{value:0},indirectLightIntensity:{value:.1},rimTexture:{value:null},rimColor:{value:new e.Color(0,0,0)},rimLightingMix:{value:0},rimFresnelPower:{value:1},rimLift:{value:0},sphereAdd:{value:null},emissionColor:{value:new e.Color(0,0,0)},outlineWidthTexture:{value:null},outlineWidth:{value:.5},outlineScaledMaxDistance:{value:1},outlineColor:{value:new e.Color(0,0,0)},outlineLightingMix:{value:1},uvAnimMaskTexture:{value:null},uvAnimOffsetX:{value:0},uvAnimOffsetY:{value:0},uvAnimTheta:{value:0}}]),this.setValues(r),this._updateShaderCode(),this._applyUniforms()}get mainTex(){return this.map}set mainTex(e){this.map=e}get bumpMap(){return this.normalMap}set bumpMap(e){this.normalMap=e}get bumpScale(){return this.normalScale.x}set bumpScale(e){this.normalScale.set(e,e)}get emissionMap(){return this.emissiveMap}set emissionMap(e){this.emissiveMap=e}get blendMode(){return this._blendMode}set blendMode(e){this._blendMode=e,this.depthWrite=this._blendMode!==Z.Transparent,this.transparent=this._blendMode===Z.Transparent||this._blendMode===Z.TransparentWithZWrite,this._updateShaderCode()}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode=e,this._updateShaderCode()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,this._updateShaderCode()}get outlineColorMode(){return this._outlineColorMode}set outlineColorMode(e){this._outlineColorMode=e,this._updateShaderCode()}get cullMode(){return this._cullMode}set cullMode(e){this._cullMode=e,this._updateCullFace()}get outlineCullMode(){return this._outlineCullMode}set outlineCullMode(e){this._outlineCullMode=e,this._updateCullFace()}get zWrite(){return this.depthWrite?1:0}set zWrite(e){this.depthWrite=.5<=e}get isOutline(){return this._isOutline}set isOutline(e){this._isOutline=e,this._updateShaderCode(),this._updateCullFace()}updateVRMMaterials(e){this._uvAnimOffsetX=this._uvAnimOffsetX+e*this.uvAnimScrollX,this._uvAnimOffsetY=this._uvAnimOffsetY-e*this.uvAnimScrollY,this._uvAnimPhase=this._uvAnimPhase+e*this.uvAnimRotation,this._applyUniforms()}copy(e){return super.copy(e),this.cutoff=e.cutoff,this.color.copy(e.color),this.shadeColor.copy(e.shadeColor),this.map=e.map,this.mainTex_ST.copy(e.mainTex_ST),this.shadeTexture=e.shadeTexture,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(this.normalScale),this.receiveShadowRate=e.receiveShadowRate,this.receiveShadowTexture=e.receiveShadowTexture,this.shadingGradeRate=e.shadingGradeRate,this.shadingGradeTexture=e.shadingGradeTexture,this.shadeShift=e.shadeShift,this.shadeToony=e.shadeToony,this.lightColorAttenuation=e.lightColorAttenuation,this.indirectLightIntensity=e.indirectLightIntensity,this.rimTexture=e.rimTexture,this.rimColor.copy(e.rimColor),this.rimLightingMix=e.rimLightingMix,this.rimFresnelPower=e.rimFresnelPower,this.rimLift=e.rimLift,this.sphereAdd=e.sphereAdd,this.emissionColor.copy(e.emissionColor),this.emissiveMap=e.emissiveMap,this.outlineWidthTexture=e.outlineWidthTexture,this.outlineWidth=e.outlineWidth,this.outlineScaledMaxDistance=e.outlineScaledMaxDistance,this.outlineColor.copy(e.outlineColor),this.outlineLightingMix=e.outlineLightingMix,this.uvAnimMaskTexture=e.uvAnimMaskTexture,this.uvAnimScrollX=e.uvAnimScrollX,this.uvAnimScrollY=e.uvAnimScrollY,this.uvAnimRotation=e.uvAnimRotation,this.debugMode=e.debugMode,this.blendMode=e.blendMode,this.outlineWidthMode=e.outlineWidthMode,this.outlineColorMode=e.outlineColorMode,this.cullMode=e.cullMode,this.outlineCullMode=e.outlineCullMode,this.isOutline=e.isOutline,this}_applyUniforms(){this.uniforms.uvAnimOffsetX.value=this._uvAnimOffsetX,this.uniforms.uvAnimOffsetY.value=this._uvAnimOffsetY,this.uniforms.uvAnimTheta.value=j*this._uvAnimPhase,this.shouldApplyUniforms&&(this.shouldApplyUniforms=!1,this.uniforms.cutoff.value=this.cutoff,this.uniforms.color.value.setRGB(this.color.x,this.color.y,this.color.z),this.uniforms.colorAlpha.value=this.color.w,this.uniforms.shadeColor.value.setRGB(this.shadeColor.x,this.shadeColor.y,this.shadeColor.z),this.uniforms.map.value=this.map,this.uniforms.mainTex_ST.value.copy(this.mainTex_ST),this.uniforms.shadeTexture.value=this.shadeTexture,this.uniforms.normalMap.value=this.normalMap,this.uniforms.normalScale.value.copy(this.normalScale),this.uniforms.receiveShadowRate.value=this.receiveShadowRate,this.uniforms.receiveShadowTexture.value=this.receiveShadowTexture,this.uniforms.shadingGradeRate.value=this.shadingGradeRate,this.uniforms.shadingGradeTexture.value=this.shadingGradeTexture,this.uniforms.shadeShift.value=this.shadeShift,this.uniforms.shadeToony.value=this.shadeToony,this.uniforms.lightColorAttenuation.value=this.lightColorAttenuation,this.uniforms.indirectLightIntensity.value=this.indirectLightIntensity,this.uniforms.rimTexture.value=this.rimTexture,this.uniforms.rimColor.value.setRGB(this.rimColor.x,this.rimColor.y,this.rimColor.z),this.uniforms.rimLightingMix.value=this.rimLightingMix,this.uniforms.rimFresnelPower.value=this.rimFresnelPower,this.uniforms.rimLift.value=this.rimLift,this.uniforms.sphereAdd.value=this.sphereAdd,this.uniforms.emissionColor.value.setRGB(this.emissionColor.x,this.emissionColor.y,this.emissionColor.z),this.uniforms.emissiveMap.value=this.emissiveMap,this.uniforms.outlineWidthTexture.value=this.outlineWidthTexture,this.uniforms.outlineWidth.value=this.outlineWidth,this.uniforms.outlineScaledMaxDistance.value=this.outlineScaledMaxDistance,this.uniforms.outlineColor.value.setRGB(this.outlineColor.x,this.outlineColor.y,this.outlineColor.z),this.uniforms.outlineLightingMix.value=this.outlineLightingMix,this.uniforms.uvAnimMaskTexture.value=this.uvAnimMaskTexture,this.encoding===e.sRGBEncoding&&(this.uniforms.color.value.convertSRGBToLinear(),this.uniforms.shadeColor.value.convertSRGBToLinear(),this.uniforms.rimColor.value.convertSRGBToLinear(),this.uniforms.emissionColor.value.convertSRGBToLinear(),this.uniforms.outlineColor.value.convertSRGBToLinear()),this._updateCullFace())}_updateShaderCode(){const r=null!==this.outlineWidthTexture,t=null!==this.map||null!==this.shadeTexture||null!==this.receiveShadowTexture||null!==this.shadingGradeTexture||null!==this.rimTexture||null!==this.uvAnimMaskTexture;this.defines={THREE_VRM_THREE_REVISION_126:parseInt(e.REVISION)>=126,OUTLINE:this._isOutline,BLENDMODE_OPAQUE:this._blendMode===Z.Opaque,BLENDMODE_CUTOUT:this._blendMode===Z.Cutout,BLENDMODE_TRANSPARENT:this._blendMode===Z.Transparent||this._blendMode===Z.TransparentWithZWrite,MTOON_USE_UV:r||t,MTOON_UVS_VERTEX_ONLY:r&&!t,USE_SHADETEXTURE:null!==this.shadeTexture,USE_RECEIVESHADOWTEXTURE:null!==this.receiveShadowTexture,USE_SHADINGGRADETEXTURE:null!==this.shadingGradeTexture,USE_RIMTEXTURE:null!==this.rimTexture,USE_SPHEREADD:null!==this.sphereAdd,USE_OUTLINEWIDTHTEXTURE:null!==this.outlineWidthTexture,USE_UVANIMMASKTEXTURE:null!==this.uvAnimMaskTexture,DEBUG_NORMAL:this._debugMode===X.Normal,DEBUG_LITSHADERATE:this._debugMode===X.LitShadeRate,DEBUG_UV:this._debugMode===X.UV,OUTLINE_WIDTH_WORLD:this._outlineWidthMode===Q.WorldCoordinates,OUTLINE_WIDTH_SCREEN:this._outlineWidthMode===Q.ScreenCoordinates,OUTLINE_COLOR_FIXED:this._outlineColorMode===q.FixedColor,OUTLINE_COLOR_MIXED:this._outlineColorMode===q.MixedLighting};const n=(null!==this.shadeTexture?z("shadeTextureTexelToLinear",this.shadeTexture.encoding)+"\n":"")+(null!==this.sphereAdd?z("sphereAddTexelToLinear",this.sphereAdd.encoding)+"\n":"")+(null!==this.rimTexture?z("rimTextureTexelToLinear",this.rimTexture.encoding)+"\n":"");this.vertexShader="// #define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#include <common>\r\n\r\n// #include <uv_pars_vertex>\r\n#ifdef MTOON_USE_UV\r\n  #ifdef MTOON_UVS_VERTEX_ONLY\r\n    vec2 vUv;\r\n  #else\r\n    varying vec2 vUv;\r\n  #endif\r\n\r\n  uniform vec4 mainTex_ST;\r\n#endif\r\n\r\n#include <uv2_pars_vertex>\r\n// #include <displacementmap_pars_vertex>\r\n// #include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\n#ifdef USE_OUTLINEWIDTHTEXTURE\r\n  uniform sampler2D outlineWidthTexture;\r\n#endif\r\n\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\n\r\nvoid main() {\r\n\r\n  // #include <uv_vertex>\r\n  #ifdef MTOON_USE_UV\r\n    vUv = uv;\r\n    vUv.y = 1.0 - vUv.y; // uv.y is opposite from UniVRM's\r\n    vUv = mainTex_ST.st + mainTex_ST.pq * vUv;\r\n    vUv.y = 1.0 - vUv.y; // reverting the previous flip\r\n  #endif\r\n\r\n  #include <uv2_vertex>\r\n  #include <color_vertex>\r\n\r\n  #include <beginnormal_vertex>\r\n  #include <morphnormal_vertex>\r\n  #include <skinbase_vertex>\r\n  #include <skinnormal_vertex>\r\n\r\n  // we need this to compute the outline properly\r\n  objectNormal = normalize( objectNormal );\r\n\r\n  #include <defaultnormal_vertex>\r\n\r\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n    vNormal = normalize( transformedNormal );\r\n  #endif\r\n\r\n  #include <begin_vertex>\r\n\r\n  #include <morphtarget_vertex>\r\n  #include <skinning_vertex>\r\n  // #include <displacementmap_vertex>\r\n  #include <project_vertex>\r\n  #include <logdepthbuf_vertex>\r\n  #include <clipping_planes_vertex>\r\n\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n  float outlineTex = 1.0;\r\n\r\n  #ifdef OUTLINE\r\n    #ifdef USE_OUTLINEWIDTHTEXTURE\r\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\r\n    #endif\r\n\r\n    #ifdef OUTLINE_WIDTH_WORLD\r\n      float worldNormalLength = length( transformedNormal );\r\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * worldNormalLength * objectNormal;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\r\n    #endif\r\n\r\n    #ifdef OUTLINE_WIDTH_SCREEN\r\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\r\n      vec2 projectedNormal = normalize( clipNormal.xy );\r\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\r\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\r\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\r\n    #endif\r\n\r\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\r\n  #endif\r\n\r\n  #include <worldpos_vertex>\r\n  // #include <envmap_vertex>\r\n  #include <shadowmap_vertex>\r\n  #include <fog_vertex>\r\n\r\n}",this.fragmentShader=n+'// #define PHONG\r\n\r\n#ifdef BLENDMODE_CUTOUT\r\n  uniform float cutoff;\r\n#endif\r\n\r\nuniform vec3 color;\r\nuniform float colorAlpha;\r\nuniform vec3 shadeColor;\r\n#ifdef USE_SHADETEXTURE\r\n  uniform sampler2D shadeTexture;\r\n#endif\r\n\r\nuniform float receiveShadowRate;\r\n#ifdef USE_RECEIVESHADOWTEXTURE\r\n  uniform sampler2D receiveShadowTexture;\r\n#endif\r\n\r\nuniform float shadingGradeRate;\r\n#ifdef USE_SHADINGGRADETEXTURE\r\n  uniform sampler2D shadingGradeTexture;\r\n#endif\r\n\r\nuniform float shadeShift;\r\nuniform float shadeToony;\r\nuniform float lightColorAttenuation;\r\nuniform float indirectLightIntensity;\r\n\r\n#ifdef USE_RIMTEXTURE\r\n  uniform sampler2D rimTexture;\r\n#endif\r\nuniform vec3 rimColor;\r\nuniform float rimLightingMix;\r\nuniform float rimFresnelPower;\r\nuniform float rimLift;\r\n\r\n#ifdef USE_SPHEREADD\r\n  uniform sampler2D sphereAdd;\r\n#endif\r\n\r\nuniform vec3 emissionColor;\r\n\r\nuniform vec3 outlineColor;\r\nuniform float outlineLightingMix;\r\n\r\n#ifdef USE_UVANIMMASKTEXTURE\r\n  uniform sampler2D uvAnimMaskTexture;\r\n#endif\r\n\r\nuniform float uvAnimOffsetX;\r\nuniform float uvAnimOffsetY;\r\nuniform float uvAnimTheta;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n\r\n// #include <uv_pars_fragment>\r\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\r\n  varying vec2 vUv;\r\n#endif\r\n\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n// #include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n// #include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n// #include <envmap_common_pars_fragment>\r\n// #include <envmap_pars_fragment>\r\n// #include <cube_uv_reflection_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n\r\n// #include <lights_phong_pars_fragment>\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\nstruct MToonMaterial {\r\n  vec3 diffuseColor;\r\n  vec3 shadeColor;\r\n  float shadingGrade;\r\n  float receiveShadow;\r\n};\r\n\r\n#define Material_LightProbeLOD( material ) (0)\r\n\r\n#include <shadowmap_pars_fragment>\r\n// #include <bumpmap_pars_fragment>\r\n\r\n// #include <normalmap_pars_fragment>\r\n#ifdef USE_NORMALMAP\r\n\r\n  uniform sampler2D normalMap;\r\n  uniform vec2 normalScale;\r\n\r\n#endif\r\n\r\n#ifdef OBJECTSPACE_NORMALMAP\r\n\r\n  uniform mat3 normalMatrix;\r\n\r\n#endif\r\n\r\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\r\n\r\n  // Per-Pixel Tangent Space Normal Mapping\r\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\r\n\r\n  // Temporary compat against shader change @ Three.js r126\r\n  // See: #21205, #21307, #21299\r\n  #ifdef THREE_VRM_THREE_REVISION_126\r\n\r\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\r\n\r\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n      vec2 st0 = dFdx( uv.st );\r\n      vec2 st1 = dFdy( uv.st );\r\n\r\n      vec3 N = normalize( surf_norm );\r\n\r\n      vec3 q1perp = cross( q1, N );\r\n      vec3 q0perp = cross( N, q0 );\r\n\r\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\r\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\r\n\r\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\r\n      // TODO: Is this still required? Or shall I make a PR about it?\r\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\r\n        return surf_norm;\r\n      }\r\n\r\n      float det = max( dot( T, T ), dot( B, B ) );\r\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\r\n\r\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\r\n\r\n    }\r\n\r\n  #else\r\n\r\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\r\n\r\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n      vec2 st0 = dFdx( uv.st );\r\n      vec2 st1 = dFdy( uv.st );\r\n\r\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\r\n\r\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\r\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\r\n\r\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\r\n      // TODO: Is this still required? Or shall I make a PR about it?\r\n\r\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\r\n        return surf_norm;\r\n      }\r\n\r\n      S = normalize( S );\r\n      T = normalize( T );\r\n      vec3 N = normalize( surf_norm );\r\n\r\n      #ifdef DOUBLE_SIDED\r\n\r\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\r\n\r\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\r\n\r\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\r\n\r\n      #else\r\n\r\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n\r\n      #endif\r\n\r\n      mat3 tsn = mat3( S, T, N );\r\n      return normalize( tsn * mapN );\r\n\r\n    }\r\n\r\n  #endif\r\n\r\n#endif\r\n\r\n// #include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\n// == lighting stuff ===========================================================\r\nfloat getLightIntensity(\r\n  const in IncidentLight directLight,\r\n  const in GeometricContext geometry,\r\n  const in float shadow,\r\n  const in float shadingGrade\r\n) {\r\n  float lightIntensity = dot( geometry.normal, directLight.direction );\r\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\r\n  lightIntensity = lightIntensity * shadow;\r\n  lightIntensity = lightIntensity * shadingGrade;\r\n  lightIntensity = lightIntensity * 2.0 - 1.0;\r\n  return shadeToony == 1.0\r\n    ? step( shadeShift, lightIntensity )\r\n    : smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\r\n}\r\n\r\nvec3 getLighting( const in vec3 lightColor ) {\r\n  vec3 lighting = lightColor;\r\n  lighting = mix(\r\n    lighting,\r\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\r\n    lightColorAttenuation\r\n  );\r\n\r\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\r\n    lighting *= PI;\r\n  #endif\r\n\r\n  return lighting;\r\n}\r\n\r\nvec3 getDiffuse(\r\n  const in MToonMaterial material,\r\n  const in float lightIntensity,\r\n  const in vec3 lighting\r\n) {\r\n  #ifdef DEBUG_LITSHADERATE\r\n    return vec3( BRDF_Diffuse_Lambert( lightIntensity * lighting ) );\r\n  #endif\r\n\r\n  return lighting * BRDF_Diffuse_Lambert( mix( material.shadeColor, material.diffuseColor, lightIntensity ) );\r\n}\r\n\r\n// == post correction ==========================================================\r\nvoid postCorrection() {\r\n  #include <tonemapping_fragment>\r\n  #include <encodings_fragment>\r\n  #include <fog_fragment>\r\n  #include <premultiplied_alpha_fragment>\r\n  #include <dithering_fragment>\r\n}\r\n\r\n// == main procedure ===========================================================\r\nvoid main() {\r\n  #include <clipping_planes_fragment>\r\n\r\n  vec2 uv = vec2(0.5, 0.5);\r\n\r\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\r\n    uv = vUv;\r\n\r\n    float uvAnimMask = 1.0;\r\n    #ifdef USE_UVANIMMASKTEXTURE\r\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\r\n    #endif\r\n\r\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\r\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\r\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\r\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\r\n  #endif\r\n\r\n  #ifdef DEBUG_UV\r\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\r\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n  vec4 diffuseColor = vec4( color, colorAlpha );\r\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n  vec3 totalEmissiveRadiance = emissionColor;\r\n\r\n  #include <logdepthbuf_fragment>\r\n\r\n  // #include <map_fragment>\r\n  #ifdef USE_MAP\r\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\r\n  #endif\r\n\r\n  #include <color_fragment>\r\n  // #include <alphamap_fragment>\r\n\r\n  // -- MToon: alpha -----------------------------------------------------------\r\n  // #include <alphatest_fragment>\r\n  #ifdef BLENDMODE_CUTOUT\r\n    if ( diffuseColor.a <= cutoff ) { discard; }\r\n    diffuseColor.a = 1.0;\r\n  #endif\r\n\r\n  #ifdef BLENDMODE_OPAQUE\r\n    diffuseColor.a = 1.0;\r\n  #endif\r\n\r\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\r\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\r\n    postCorrection();\r\n    return;\r\n  #endif\r\n\r\n  // #include <specularmap_fragment>\r\n  #include <normal_fragment_begin>\r\n\r\n  #ifdef OUTLINE\r\n    normal *= -1.0;\r\n  #endif\r\n\r\n  // #include <normal_fragment_maps>\r\n\r\n  #ifdef OBJECTSPACE_NORMALMAP\r\n\r\n    normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\r\n\r\n    #ifdef FLIP_SIDED\r\n\r\n      normal = - normal;\r\n\r\n    #endif\r\n\r\n    #ifdef DOUBLE_SIDED\r\n\r\n      // Temporary compat against shader change @ Three.js r126\r\n      // See: #21205, #21307, #21299\r\n      #ifdef THREE_VRM_THREE_REVISION_126\r\n\r\n        normal = normal * faceDirection;\r\n\r\n      #else\r\n\r\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n\r\n      #endif\r\n\r\n    #endif\r\n\r\n    normal = normalize( normalMatrix * normal );\r\n\r\n  #elif defined( TANGENTSPACE_NORMALMAP )\r\n\r\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\r\n    mapN.xy *= normalScale;\r\n\r\n    #ifdef USE_TANGENT\r\n\r\n      normal = normalize( vTBN * mapN );\r\n\r\n    #else\r\n\r\n      // Temporary compat against shader change @ Three.js r126\r\n      // See: #21205, #21307, #21299\r\n      #ifdef THREE_VRM_THREE_REVISION_126\r\n\r\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\r\n\r\n      #else\r\n\r\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\r\n\r\n      #endif\r\n\r\n    #endif\r\n\r\n  #endif\r\n\r\n  // #include <emissivemap_fragment>\r\n  #ifdef USE_EMISSIVEMAP\r\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\r\n  #endif\r\n\r\n  #ifdef DEBUG_NORMAL\r\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\r\n    return;\r\n  #endif\r\n\r\n  // -- MToon: lighting --------------------------------------------------------\r\n  // accumulation\r\n  // #include <lights_phong_fragment>\r\n  MToonMaterial material;\r\n\r\n  material.diffuseColor = diffuseColor.rgb;\r\n\r\n  material.shadeColor = shadeColor;\r\n  #ifdef USE_SHADETEXTURE\r\n    material.shadeColor *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\r\n  #endif\r\n\r\n  material.shadingGrade = 1.0;\r\n  #ifdef USE_SHADINGGRADETEXTURE\r\n    material.shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\r\n  #endif\r\n\r\n  material.receiveShadow = receiveShadowRate;\r\n  #ifdef USE_RECEIVESHADOWTEXTURE\r\n    material.receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\r\n  #endif\r\n\r\n  // #include <lights_fragment_begin>\r\n  GeometricContext geometry;\r\n\r\n  geometry.position = - vViewPosition;\r\n  geometry.normal = normal;\r\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\r\n\r\n  IncidentLight directLight;\r\n  vec3 lightingSum = vec3( 0.0 );\r\n\r\n  #if ( NUM_POINT_LIGHTS > 0 )\r\n    PointLight pointLight;\r\n\r\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n    PointLightShadow pointLightShadow;\r\n    #endif\r\n\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n      pointLight = pointLights[ i ];\r\n      getPointDirectLightIrradiance( pointLight, geometry, directLight );\r\n\r\n      float atten = 1.0;\r\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n      pointLightShadow = pointLightShadows[ i ];\r\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n      #endif\r\n\r\n      float shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\r\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\r\n      vec3 lighting = getLighting( directLight.color );\r\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\r\n      lightingSum += lighting;\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n\r\n  #if ( NUM_SPOT_LIGHTS > 0 )\r\n    SpotLight spotLight;\r\n\r\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n    SpotLightShadow spotLightShadow;\r\n    #endif\r\n\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n      spotLight = spotLights[ i ];\r\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\r\n\r\n      float atten = 1.0;\r\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n      spotLightShadow = spotLightShadows[ i ];\r\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n      #endif\r\n\r\n      float shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\r\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\r\n      vec3 lighting = getLighting( directLight.color );\r\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\r\n      lightingSum += lighting;\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n\r\n  #if ( NUM_DIR_LIGHTS > 0 )\r\n    DirectionalLight directionalLight;\r\n\r\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n    DirectionalLightShadow directionalLightShadow;\r\n    #endif\r\n\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      directionalLight = directionalLights[ i ];\r\n      getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n\r\n      float atten = 1.0;\r\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n      directionalLightShadow = directionalLightShadows[ i ];\r\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n      #endif\r\n\r\n      float shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\r\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\r\n      vec3 lighting = getLighting( directLight.color );\r\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\r\n      lightingSum += lighting;\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n\r\n  // #if defined( RE_IndirectDiffuse )\r\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n  irradiance += getLightProbeIrradiance( lightProbe, geometry );\r\n  #if ( NUM_HEMI_LIGHTS > 0 )\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n  // #endif\r\n\r\n  // #include <lights_fragment_maps>\r\n  #ifdef USE_LIGHTMAP\r\n    vec4 lightMapTexel = texture2D( lightMap, vUv2 );\r\n    vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\r\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\r\n      lightMapIrradiance *= PI;\r\n    #endif\r\n    irradiance += lightMapIrradiance;\r\n  #endif\r\n\r\n  // #include <lights_fragment_end>\r\n  // RE_IndirectDiffuse here\r\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n  // modulation\r\n  #include <aomap_fragment>\r\n\r\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\r\n\r\n  // The "comment out if you want to PBR absolutely" line\r\n  #ifndef DEBUG_LITSHADERATE\r\n    col = min(col, material.diffuseColor);\r\n  #endif\r\n\r\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED )\r\n    gl_FragColor = vec4(\r\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\r\n      diffuseColor.a\r\n    );\r\n    postCorrection();\r\n    return;\r\n  #endif\r\n\r\n  #ifdef DEBUG_LITSHADERATE\r\n    gl_FragColor = vec4( col, diffuseColor.a );\r\n    postCorrection();\r\n    return;\r\n  #endif\r\n\r\n  // -- MToon: parametric rim lighting -----------------------------------------\r\n  vec3 viewDir = normalize( vViewPosition );\r\n  vec3 rimMix = mix( vec3( 1.0 ), lightingSum + indirectLightIntensity * irradiance, rimLightingMix );\r\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\r\n  #ifdef USE_RIMTEXTURE\r\n    rim *= rimTextureTexelToLinear( texture2D( rimTexture, uv ) ).rgb;\r\n  #endif\r\n  col += rim;\r\n\r\n  // -- MToon: additive matcap -------------------------------------------------\r\n  #ifdef USE_SPHEREADD\r\n    {\r\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\r\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\r\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\r\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\r\n      col += matcap;\r\n    }\r\n  #endif\r\n\r\n  // -- MToon: Emission --------------------------------------------------------\r\n  col += totalEmissiveRadiance;\r\n\r\n  // #include <envmap_fragment>\r\n\r\n  // -- Almost done! -----------------------------------------------------------\r\n  gl_FragColor = vec4( col, diffuseColor.a );\r\n  postCorrection();\r\n}',this.needsUpdate=!0}_updateCullFace(){this.isOutline?this.outlineCullMode===Y.Off?this.side=e.DoubleSide:this.outlineCullMode===Y.Front?this.side=e.BackSide:this.outlineCullMode===Y.Back&&(this.side=e.FrontSide):this.cullMode===Y.Off?this.side=e.DoubleSide:this.cullMode===Y.Front?this.side=e.BackSide:this.cullMode===Y.Back&&(this.side=e.FrontSide)}}var J;!function(e){e[e.Opaque=0]="Opaque",e[e.Cutout=1]="Cutout",e[e.Transparent=2]="Transparent",e[e.TransparentWithZWrite=3]="TransparentWithZWrite"}(J||(J={}));class K extends e.ShaderMaterial{constructor(r){super(),this.isVRMUnlitMaterial=!0,this.cutoff=.5,this.map=null,this.mainTex_ST=new e.Vector4(0,0,1,1),this._renderType=J.Opaque,this.shouldApplyUniforms=!0,void 0===r&&(r={}),r.fog=!0,r.clipping=!0,r.skinning=r.skinning||!1,r.morphTargets=r.morphTargets||!1,r.morphNormals=r.morphNormals||!1,r.uniforms=e.UniformsUtils.merge([e.UniformsLib.common,e.UniformsLib.fog,{cutoff:{value:.5},mainTex_ST:{value:new e.Vector4(0,0,1,1)}}]),this.setValues(r),this._updateShaderCode(),this._applyUniforms()}get mainTex(){return this.map}set mainTex(e){this.map=e}get renderType(){return this._renderType}set renderType(e){this._renderType=e,this.depthWrite=this._renderType!==J.Transparent,this.transparent=this._renderType===J.Transparent||this._renderType===J.TransparentWithZWrite,this._updateShaderCode()}updateVRMMaterials(e){this._applyUniforms()}copy(e){return super.copy(e),this.cutoff=e.cutoff,this.map=e.map,this.mainTex_ST.copy(e.mainTex_ST),this.renderType=e.renderType,this}_applyUniforms(){this.shouldApplyUniforms&&(this.shouldApplyUniforms=!1,this.uniforms.cutoff.value=this.cutoff,this.uniforms.map.value=this.map,this.uniforms.mainTex_ST.value.copy(this.mainTex_ST))}_updateShaderCode(){this.defines={RENDERTYPE_OPAQUE:this._renderType===J.Opaque,RENDERTYPE_CUTOUT:this._renderType===J.Cutout,RENDERTYPE_TRANSPARENT:this._renderType===J.Transparent||this._renderType===J.TransparentWithZWrite},this.vertexShader="#include <common>\r\n\r\n// #include <uv_pars_vertex>\r\n#ifdef USE_MAP\r\n  varying vec2 vUv;\r\n  uniform vec4 mainTex_ST;\r\n#endif\r\n\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n  // #include <uv_vertex>\r\n  #ifdef USE_MAP\r\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\r\n  #endif\r\n\r\n  #include <uv2_vertex>\r\n  #include <color_vertex>\r\n  #include <skinbase_vertex>\r\n\r\n  #ifdef USE_ENVMAP\r\n\r\n  #include <beginnormal_vertex>\r\n  #include <morphnormal_vertex>\r\n  #include <skinnormal_vertex>\r\n  #include <defaultnormal_vertex>\r\n\r\n  #endif\r\n\r\n  #include <begin_vertex>\r\n  #include <morphtarget_vertex>\r\n  #include <skinning_vertex>\r\n  #include <project_vertex>\r\n  #include <logdepthbuf_vertex>\r\n\r\n  #include <worldpos_vertex>\r\n  #include <clipping_planes_vertex>\r\n  #include <envmap_vertex>\r\n  #include <fog_vertex>\r\n\r\n}",this.fragmentShader="#ifdef RENDERTYPE_CUTOUT\r\n  uniform float cutoff;\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n// #include <alphamap_pars_fragment>\r\n// #include <aomap_pars_fragment>\r\n// #include <lightmap_pars_fragment>\r\n// #include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n// #include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\n// == main procedure ===========================================================\r\nvoid main() {\r\n  #include <clipping_planes_fragment>\r\n\r\n  vec4 diffuseColor = vec4( 1.0 );\r\n\r\n  #include <logdepthbuf_fragment>\r\n\r\n  // #include <map_fragment>\r\n  #ifdef USE_MAP\r\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\r\n  #endif\r\n\r\n  #include <color_fragment>\r\n  // #include <alphamap_fragment>\r\n\r\n  // MToon: alpha\r\n  // #include <alphatest_fragment>\r\n  #ifdef RENDERTYPE_CUTOUT\r\n    if ( diffuseColor.a <= cutoff ) { discard; }\r\n    diffuseColor.a = 1.0;\r\n  #endif\r\n\r\n  #ifdef RENDERTYPE_OPAQUE\r\n    diffuseColor.a = 1.0;\r\n  #endif\r\n\r\n  // #include <specularmap_fragment>\r\n\r\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n  // accumulation (baked indirect lighting only)\r\n  #ifdef USE_LIGHTMAP\r\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n  #else\r\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\r\n  #endif\r\n\r\n  // modulation\r\n  // #include <aomap_fragment>\r\n\r\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n  // #include <envmap_fragment>\r\n\r\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n  #include <premultiplied_alpha_fragment>\r\n  #include <tonemapping_fragment>\r\n  #include <encodings_fragment>\r\n  #include <fog_fragment>\r\n}",this.needsUpdate=!0}}class ee{constructor(r={}){this._encoding=r.encoding||e.LinearEncoding,this._encoding!==e.LinearEncoding&&this._encoding!==e.sRGBEncoding&&console.warn("The specified color encoding might not work properly with VRMMaterialImporter. You might want to use THREE.sRGBEncoding instead."),this._requestEnvMap=r.requestEnvMap}convertGLTFMaterials(e){var t;return r(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.materialProperties;if(!i)return null;const o=yield c(e),s={},a=[];return yield Promise.all(Array.from(o.entries()).map((([t,n])=>r(this,void 0,void 0,(function*(){const o=e.parser.json.nodes[t],l=e.parser.json.meshes[o.mesh];yield Promise.all(n.map(((t,n)=>r(this,void 0,void 0,(function*(){const r=l.primitives[n];if(!r)return;const o=t.geometry,d=o.index?o.index.count:o.attributes.position.count/3;Array.isArray(t.material)||(t.material=[t.material],o.addGroup(0,d,0));const h=r.material;let u,c=i[h];c||(console.warn(`VRMMaterialImporter: There are no material definition for material #${h} on VRM extension.`),c={shader:"VRM_USE_GLTFSHADER"}),s[h]?u=s[h]:(u=yield this.createVRMMaterials(t.material[0],c,e),s[h]=u,a.push(u.surface),u.outline&&a.push(u.outline)),t.material[0]=u.surface,this._requestEnvMap&&u.surface.isMeshStandardMaterial&&this._requestEnvMap().then((e=>{u.surface.envMap=e,u.surface.needsUpdate=!0})),t.renderOrder=c.renderQueue||2e3,u.outline&&(t.material[1]=u.outline,o.addGroup(0,d,1))})))))}))))),a}))}createVRMMaterials(e,t,n){return r(this,void 0,void 0,(function*(){let r,i;if("VRM/MToon"===t.shader){const o=yield this._extractMaterialProperties(e,t,n);["srcBlend","dstBlend","isFirstSetup"].forEach((e=>{void 0!==o[e]&&delete o[e]})),["mainTex","shadeTexture","emissionMap","sphereAdd","rimTexture"].forEach((e=>{void 0!==o[e]&&(o[e].encoding=this._encoding)})),o.encoding=this._encoding,r=new $(o),o.outlineWidthMode!==Q.None&&(o.isOutline=!0,i=new $(o))}else if("VRM/UnlitTexture"===t.shader){const i=yield this._extractMaterialProperties(e,t,n);i.renderType=J.Opaque,r=new K(i)}else if("VRM/UnlitCutout"===t.shader){const i=yield this._extractMaterialProperties(e,t,n);i.renderType=J.Cutout,r=new K(i)}else if("VRM/UnlitTransparent"===t.shader){const i=yield this._extractMaterialProperties(e,t,n);i.renderType=J.Transparent,r=new K(i)}else if("VRM/UnlitTransparentZWrite"===t.shader){const i=yield this._extractMaterialProperties(e,t,n);i.renderType=J.TransparentWithZWrite,r=new K(i)}else"VRM_USE_GLTFSHADER"!==t.shader&&console.warn(`Unknown shader detected: "${t.shader}"`),r=this._convertGLTFMaterial(e.clone());return r.name=e.name,r.userData=JSON.parse(JSON.stringify(e.userData)),r.userData.vrmMaterialProperties=t,i&&(i.name=e.name+" (Outline)",i.userData=JSON.parse(JSON.stringify(e.userData)),i.userData.vrmMaterialProperties=t),{surface:r,outline:i}}))}_renameMaterialProperty(e){return"_"!==e[0]?(console.warn(`VRMMaterials: Given property name "${e}" might be invalid`),e):(e=e.substring(1),/[A-Z]/.test(e[0])?e[0].toLowerCase()+e.substring(1):(console.warn(`VRMMaterials: Given property name "${e}" might be invalid`),e))}_convertGLTFMaterial(r){if(r.isMeshStandardMaterial){const t=r;t.map&&(t.map.encoding=this._encoding),t.emissiveMap&&(t.emissiveMap.encoding=this._encoding),this._encoding===e.LinearEncoding&&(t.color.convertLinearToSRGB(),t.emissive.convertLinearToSRGB())}if(r.isMeshBasicMaterial){const t=r;t.map&&(t.map.encoding=this._encoding),this._encoding===e.LinearEncoding&&t.color.convertLinearToSRGB()}return r}_extractMaterialProperties(r,t,n){const i=[],o={};if(t.textureProperties)for(const e of Object.keys(t.textureProperties)){const r=this._renameMaterialProperty(e),s=t.textureProperties[e];i.push(n.parser.getDependency("texture",s).then((e=>{o[r]=e})))}if(t.floatProperties)for(const e of Object.keys(t.floatProperties)){const r=this._renameMaterialProperty(e);o[r]=t.floatProperties[e]}if(t.vectorProperties)for(const r of Object.keys(t.vectorProperties)){let n=this._renameMaterialProperty(r);["_MainTex","_ShadeTexture","_BumpMap","_ReceiveShadowTexture","_ShadingGradeTexture","_RimTexture","_SphereAdd","_EmissionMap","_OutlineWidthTexture","_UvAnimMaskTexture"].some((e=>r===e))&&(n+="_ST"),o[n]=new e.Vector4(...t.vectorProperties[r])}return o.skinning=r.skinning||!1,o.morphTargets=r.morphTargets||!1,o.morphNormals=r.morphNormals||!1,Promise.all(i).then((()=>o))}}class re{constructor(e){var r;this.ignoreTexture=null!==(r=null==e?void 0:e.ignoreTexture)&&void 0!==r&&r}import(e){var t;return r(this,void 0,void 0,(function*(){const r=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!r)return null;const n=r.meta;if(!n)return null;let i;return this.ignoreTexture||null==n.texture||-1===n.texture||(i=yield e.parser.getDependency("texture",n.texture)),{allowedUserName:n.allowedUserName,author:n.author,commercialUssageName:n.commercialUssageName,contactInformation:n.contactInformation,licenseName:n.licenseName,otherLicenseUrl:n.otherLicenseUrl,otherPermissionUrl:n.otherPermissionUrl,reference:n.reference,sexualUssageName:n.sexualUssageName,texture:null!=i?i:void 0,title:n.title,version:n.version,violentUssageName:n.violentUssageName}}))}}const te=new e.Matrix4;function ne(e){return e.invert?e.invert():e.getInverse(te.copy(e)),e}class ie{constructor(r){this._inverseCache=new e.Matrix4,this._shouldUpdateInverse=!0,this.matrix=r;const t={set:(e,r,t)=>(this._shouldUpdateInverse=!0,e[r]=t,!0)};this._originalElements=r.elements,r.elements=new Proxy(r.elements,t)}get inverse(){return this._shouldUpdateInverse&&(ne(this._inverseCache.copy(this.matrix)),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const oe=Object.freeze(new e.Matrix4),se=Object.freeze(new e.Quaternion),ae=new e.Vector3,le=new e.Vector3,de=new e.Vector3,he=new e.Quaternion,ue=new e.Matrix4,ce=new e.Matrix4;class pe{constructor(r,t={}){var n,i,o,s,a,l;if(this._currentTail=new e.Vector3,this._prevTail=new e.Vector3,this._nextTail=new e.Vector3,this._boneAxis=new e.Vector3,this._centerSpacePosition=new e.Vector3,this._center=null,this._parentWorldRotation=new e.Quaternion,this._initialLocalMatrix=new e.Matrix4,this._initialLocalRotation=new e.Quaternion,this._initialLocalChildPosition=new e.Vector3,this.bone=r,this.bone.matrixAutoUpdate=!1,this.radius=null!==(n=t.radius)&&void 0!==n?n:.02,this.stiffnessForce=null!==(i=t.stiffnessForce)&&void 0!==i?i:1,this.gravityDir=t.gravityDir?(new e.Vector3).copy(t.gravityDir):(new e.Vector3).set(0,-1,0),this.gravityPower=null!==(o=t.gravityPower)&&void 0!==o?o:0,this.dragForce=null!==(s=t.dragForce)&&void 0!==s?s:.4,this.colliders=null!==(a=t.colliders)&&void 0!==a?a:[],this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld),this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),0===this.bone.children.length)this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);else{const e=this.bone.children[0];this._initialLocalChildPosition.copy(e.position)}this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)),this._prevTail.copy(this._currentTail),this._nextTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize(),this._centerSpaceBoneLength=ae.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length(),this.center=null!==(l=t.center)&&void 0!==l?l:null}get center(){return this._center}set center(e){var r;this._getMatrixCenterToWorld(ue),this._currentTail.applyMatrix4(ue),this._prevTail.applyMatrix4(ue),this._nextTail.applyMatrix4(ue),(null===(r=this._center)||void 0===r?void 0:r.userData.inverseCacheProxy)&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=e,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new ie(this._center.matrixWorld))),this._getMatrixWorldToCenter(ue),this._currentTail.applyMatrix4(ue),this._prevTail.applyMatrix4(ue),this._nextTail.applyMatrix4(ue),ue.multiply(this.bone.matrixWorld),this._centerSpacePosition.setFromMatrixPosition(ue),this._centerSpaceBoneLength=ae.copy(this._initialLocalChildPosition).applyMatrix4(ue).sub(this._centerSpacePosition).length()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix),this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld),this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)),this._prevTail.copy(this._currentTail),this._nextTail.copy(this._currentTail)}update(e){if(e<=0)return;this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix),this.bone.parent?g(this.bone.parent,this._parentWorldRotation):this._parentWorldRotation.copy(se),this._getMatrixWorldToCenter(ue),ue.multiply(this.bone.matrixWorld),this._centerSpacePosition.setFromMatrixPosition(ue),this._getMatrixWorldToCenter(ce),ce.multiply(this._getParentMatrixWorld());const r=this.stiffnessForce*e,t=le.copy(this.gravityDir).multiplyScalar(this.gravityPower*e);this._nextTail.copy(this._currentTail).add(ae.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1-this.dragForce)).add(ae.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(ce).sub(this._centerSpacePosition).normalize().multiplyScalar(r)).add(t),this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition),this._collision(this._nextTail),this._prevTail.copy(this._currentTail),this._currentTail.copy(this._nextTail);const n=ne(ue.copy(ce.multiply(this._initialLocalMatrix))),i=he.setFromUnitVectors(this._boneAxis,ae.copy(this._nextTail).applyMatrix4(n).normalize());this.bone.quaternion.copy(this._initialLocalRotation).multiply(i),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix)}_collision(e){this.colliders.forEach((r=>{this._getMatrixWorldToCenter(ue),ue.multiply(r.matrixWorld);const t=ae.setFromMatrixPosition(ue),n=r.geometry.boundingSphere.radius,i=this.radius+n;if(e.distanceToSquared(t)<=i*i){const r=le.subVectors(e,t).normalize(),n=de.addVectors(t,r.multiplyScalar(i));e.copy(n.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition))}}))}_getMatrixCenterToWorld(e){return this._center?e.copy(this._center.matrixWorld):e.identity(),e}_getMatrixWorldToCenter(e){return this._center?e.copy(this._center.userData.inverseCacheProxy.inverse):e.identity(),e}_getParentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:oe}}class me{constructor(e,r){this.colliderGroups=[],this.springBoneGroupList=[],this.colliderGroups=e,this.springBoneGroupList=r}setCenter(e){this.springBoneGroupList.forEach((r=>{r.forEach((r=>{r.center=e}))}))}lateUpdate(e){this.springBoneGroupList.forEach((r=>{r.forEach((r=>{r.update(e)}))}))}reset(){this.springBoneGroupList.forEach((e=>{e.forEach((e=>{e.reset()}))}))}}const fe=new e.Vector3,ge=new e.MeshBasicMaterial({visible:!1});class _e{import(e){var t;return r(this,void 0,void 0,(function*(){const r=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!r)return null;const n=r.secondaryAnimation;if(!n)return null;const i=yield this._importColliderMeshGroups(e,n),o=yield this._importSpringBoneGroupList(e,n,i);return new me(i,o)}))}_createSpringBone(e,r={}){return new pe(e,r)}_importSpringBoneGroupList(t,n,i){return r(this,void 0,void 0,(function*(){const o=n.boneGroups||[],s=[];return yield Promise.all(o.map((n=>r(this,void 0,void 0,(function*(){if(void 0===n.stiffiness||void 0===n.gravityDir||void 0===n.gravityDir.x||void 0===n.gravityDir.y||void 0===n.gravityDir.z||void 0===n.gravityPower||void 0===n.dragForce||void 0===n.hitRadius||void 0===n.colliderGroups||void 0===n.bones||void 0===n.center)return;const o=n.stiffiness,a=new e.Vector3(n.gravityDir.x,n.gravityDir.y,-n.gravityDir.z),l=n.gravityPower,d=n.dragForce,h=n.hitRadius,u=[];n.colliderGroups.forEach((e=>{u.push(...i[e].colliders)}));const c=[];yield Promise.all(n.bones.map((e=>r(this,void 0,void 0,(function*(){const r=yield t.parser.getDependency("node",e),i=-1!==n.center?yield t.parser.getDependency("node",n.center):null;r&&r.traverse((e=>{const r=this._createSpringBone(e,{radius:h,stiffnessForce:o,gravityDir:a,gravityPower:l,dragForce:d,colliders:u,center:i});c.push(r)}))}))))),s.push(c)}))))),s}))}_importColliderMeshGroups(e,t){return r(this,void 0,void 0,(function*(){const n=t.colliderGroups;if(void 0===n)return[];const i=[];return n.forEach((t=>r(this,void 0,void 0,(function*(){if(void 0===t.node||void 0===t.colliders)return;const r=yield e.parser.getDependency("node",t.node),n=[];t.colliders.forEach((e=>{if(void 0===e.offset||void 0===e.offset.x||void 0===e.offset.y||void 0===e.offset.z||void 0===e.radius)return;const t=fe.set(e.offset.x,e.offset.y,-e.offset.z),i=this._createColliderMesh(e.radius,t);r.add(i),n.push(i)}));const o={node:t.node,colliders:n};i.push(o)})))),i}))}_createColliderMesh(r,t){const n=new e.Mesh(new e.SphereBufferGeometry(r,8,4),ge);return n.position.copy(t),n.name="vrmColliderSphere",n.geometry.computeBoundingSphere(),n}}class ve{constructor(e={}){this._metaImporter=e.metaImporter||new re,this._blendShapeImporter=e.blendShapeImporter||new v,this._lookAtImporter=e.lookAtImporter||new H,this._humanoidImporter=e.humanoidImporter||new C,this._firstPersonImporter=e.firstPersonImporter||new L,this._materialImporter=e.materialImporter||new ee,this._springBoneImporter=e.springBoneImporter||new _e}import(e){return r(this,void 0,void 0,(function*(){if(void 0===e.parser.json.extensions||void 0===e.parser.json.extensions.VRM)throw new Error("Could not find VRM extension on the GLTF");const r=e.scene;r.updateMatrixWorld(!1),r.traverse((e=>{e.isMesh&&(e.frustumCulled=!1)}));const t=(yield this._metaImporter.import(e))||void 0,n=(yield this._materialImporter.convertGLTFMaterials(e))||void 0,i=(yield this._humanoidImporter.import(e))||void 0,o=i&&(yield this._firstPersonImporter.import(e,i))||void 0,s=(yield this._blendShapeImporter.import(e))||void 0,a=o&&s&&i&&(yield this._lookAtImporter.import(e,o,s,i))||void 0,l=(yield this._springBoneImporter.import(e))||void 0;return new ye({scene:e.scene,meta:t,materials:n,humanoid:i,firstPerson:o,blendShapeProxy:s,lookAt:a,springBoneManager:l})}))}}class ye{constructor(e){this.scene=e.scene,this.humanoid=e.humanoid,this.blendShapeProxy=e.blendShapeProxy,this.firstPerson=e.firstPerson,this.lookAt=e.lookAt,this.materials=e.materials,this.springBoneManager=e.springBoneManager,this.meta=e.meta}static from(e,t={}){return r(this,void 0,void 0,(function*(){const r=new ve(t);return yield r.import(e)}))}update(e){this.lookAt&&this.lookAt.update(e),this.blendShapeProxy&&this.blendShapeProxy.update(),this.springBoneManager&&this.springBoneManager.lateUpdate(e),this.materials&&this.materials.forEach((r=>{r.updateVRMMaterials&&r.updateVRMMaterials(e)}))}dispose(){var e,r;const t=this.scene;t&&t.traverse(n),null===(r=null===(e=this.meta)||void 0===e?void 0:e.texture)||void 0===r||r.dispose()}}const Te=new e.Vector2,xe=new e.OrthographicCamera(-1,1,-1,1,-1,1),Me=new e.MeshBasicMaterial({color:16777215,side:e.DoubleSide}),Se=new e.Mesh(new e.PlaneBufferGeometry(2,2),Me),Le=new e.Scene;Le.add(Se);class Ee{constructor(){}}Ee.extractThumbnailBlob=function(e,r,t=512){var n;const i=null===(n=r.meta)||void 0===n?void 0:n.texture;if(!i)throw new Error("extractThumbnailBlob: This VRM does not have a thumbnail");const o=e.getContext().canvas;e.getSize(Te);const s=Te.x,a=Te.y;return e.setSize(t,t,!1),Me.map=i,e.render(Le,xe),Me.map=null,o instanceof OffscreenCanvas?o.convertToBlob().finally((()=>{e.setSize(s,a,!1)})):new Promise(((r,t)=>{o.toBlob((n=>{e.setSize(s,a,!1),null==n?t("extractThumbnailBlob: Failed to create a blob"):r(n)}))}))},Ee.removeUnnecessaryJoints=function(r){const t=new Map;r.traverse((r=>{if("SkinnedMesh"!==r.type)return;const n=r,i=n.geometry.getAttribute("skinIndex");let o=t.get(i);if(!o){const r=[],s=[],a={},l=i.array;for(let e=0;e<l.length;e++){const t=l[e];void 0===a[t]&&(a[t]=r.length,r.push(n.skeleton.bones[t]),s.push(n.skeleton.boneInverses[t])),l[e]=a[t]}i.copyArray(l),i.needsUpdate=!0,o=new e.Skeleton(r,s),t.set(i,o)}n.bind(o,new e.Matrix4)}))};const we=new e.Vector3;class Pe extends G{setupHelper(r,t){t.disableFaceDirectionHelper||(this._faceDirectionHelper=new e.ArrowHelper(new e.Vector3(0,0,-1),new e.Vector3(0,0,0),.5,16711935),r.add(this._faceDirectionHelper))}update(e){super.update(e),this._faceDirectionHelper&&(this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position),this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(we)))}}class Re extends H{import(e,r,t,n){var i;const o=null===(i=e.parser.json.extensions)||void 0===i?void 0:i.VRM;if(!o)return null;const s=o.firstPerson;if(!s)return null;const a=this._importApplyer(s,t,n);return new Pe(r,a||void 0)}}const Ae=new e.MeshBasicMaterial({color:16711935,wireframe:!0,transparent:!0,depthTest:!1});class Ce extends me{setupHelper(e,r){r.disableSpringBoneHelper||(this.springBoneGroupList.forEach((r=>{r.forEach((r=>{if(r.getGizmo){const t=r.getGizmo();e.add(t)}}))})),this.colliderGroups.forEach((e=>{e.colliders.forEach((e=>{e.material=Ae,e.renderOrder=Ue}))})))}}const be=new e.Vector3;class Oe extends pe{constructor(e,r){super(e,r)}getGizmo(){if(this._gizmo)return this._gizmo;const r=be.copy(this._nextTail).sub(this._centerSpacePosition),t=r.length();return this._gizmo=new e.ArrowHelper(r.normalize(),this._centerSpacePosition,t,16776960,this.radius,this.radius),this._gizmo.line.renderOrder=Ue,this._gizmo.cone.renderOrder=Ue,this._gizmo.line.material.depthTest=!1,this._gizmo.line.material.transparent=!0,this._gizmo.cone.material.depthTest=!1,this._gizmo.cone.material.transparent=!0,this._gizmo}update(e){super.update(e),this._updateGizmo()}_updateGizmo(){if(!this._gizmo)return;const e=be.copy(this._currentTail).sub(this._centerSpacePosition),r=e.length();this._gizmo.setDirection(e.normalize()),this._gizmo.setLength(r,this.radius,this.radius),this._gizmo.position.copy(this._centerSpacePosition)}}class De extends _e{import(e){var t;return r(this,void 0,void 0,(function*(){const r=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!r)return null;const n=r.secondaryAnimation;if(!n)return null;const i=yield this._importColliderMeshGroups(e,n),o=yield this._importSpringBoneGroupList(e,n,i);return new Ce(i,o)}))}_createSpringBone(e,r){return new Oe(e,r)}}class Ne extends ve{constructor(e={}){e.lookAtImporter=e.lookAtImporter||new Re,e.springBoneImporter=e.springBoneImporter||new De,super(e)}import(e,t={}){return r(this,void 0,void 0,(function*(){if(void 0===e.parser.json.extensions||void 0===e.parser.json.extensions.VRM)throw new Error("Could not find VRM extension on the GLTF");const r=e.scene;r.updateMatrixWorld(!1),r.traverse((e=>{e.isMesh&&(e.frustumCulled=!1)}));const n=(yield this._metaImporter.import(e))||void 0,i=(yield this._materialImporter.convertGLTFMaterials(e))||void 0,o=(yield this._humanoidImporter.import(e))||void 0,s=o&&(yield this._firstPersonImporter.import(e,o))||void 0,a=(yield this._blendShapeImporter.import(e))||void 0,l=s&&a&&o&&(yield this._lookAtImporter.import(e,s,a,o))||void 0;l.setupHelper&&l.setupHelper(r,t);const d=(yield this._springBoneImporter.import(e))||void 0;return d.setupHelper&&d.setupHelper(r,t),new Ie({scene:e.scene,meta:n,materials:i,humanoid:o,firstPerson:s,blendShapeProxy:a,lookAt:l,springBoneManager:d},t)}))}}const Ue=1e4;class Ie extends ye{static from(e,t={},n={}){return r(this,void 0,void 0,(function*(){const r=new Ne(t);return yield r.import(e,n)}))}constructor(r,t={}){super(r),t.disableBoxHelper||this.scene.add(new e.BoxHelper(this.scene)),t.disableSkeletonHelper||this.scene.add(new e.SkeletonHelper(this.scene))}update(e){super.update(e)}}export{$ as MToonMaterial,Y as MToonMaterialCullMode,X as MToonMaterialDebugMode,q as MToonMaterialOutlineColorMode,Q as MToonMaterialOutlineWidthMode,Z as MToonMaterialRenderMode,ye as VRM,d as VRMBlendShapeGroup,v as VRMBlendShapeImporter,_ as VRMBlendShapeProxy,b as VRMCurveMapper,Ie as VRMDebug,S as VRMFirstPerson,L as VRMFirstPersonImporter,E as VRMHumanBone,A as VRMHumanoid,C as VRMHumanoidImporter,ve as VRMImporter,O as VRMLookAtApplyer,D as VRMLookAtBlendShapeApplyer,k as VRMLookAtBoneApplyer,G as VRMLookAtHead,H as VRMLookAtImporter,ee as VRMMaterialImporter,re as VRMMetaImporter,M as VRMRendererFirstPersonFlags,h as VRMSchema,pe as VRMSpringBone,Oe as VRMSpringBoneDebug,_e as VRMSpringBoneImporter,De as VRMSpringBoneImporterDebug,me as VRMSpringBoneManager,K as VRMUnlitMaterial,J as VRMUnlitMaterialRenderType,Ee as VRMUtils,Ue as VRM_GIZMO_RENDER_ORDER};
